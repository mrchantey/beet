use crate::prelude::*;
use beet_common::prelude::*;
use beet_router::prelude::ClientIslandMap;
use beet_utils::prelude::WsPathBuf;
use bevy::prelude::*;
use proc_macro2::TokenStream;
use quote::quote;
use serde::Deserialize;
use serde::Serialize;
use syn::Type;

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Component)]
pub struct CollectClientIslandPlugin {
	/// Path to the [`ClientIslandMap`] generated by the [`AppRouter`]
	#[serde(default = "default_islands_map_path")]
	islands_map_path: WsPathBuf,
}

fn default_islands_map_path() -> WsPathBuf {
	WsPathBuf::new("target/client/client_islands.ron")
}


impl Default for CollectClientIslandPlugin {
	fn default() -> Self {
		Self {
			islands_map_path: default_islands_map_path(),
		}
	}
}
impl CollectClientIslandPlugin {
	pub fn load_impl(island_map: &ClientIslandMap) -> TokenStream {
		let islands = island_map.iter().map(|(route_info, islands)| {
			let route_info = route_info.self_token_stream();
			let islands = islands.iter().map(|island| {
				let ty = syn::parse_str::<Type>(island.template.type_name())
					.unwrap();
				let ron = island.template.ron();
				if island.mount {
					quote! {(
						ClientOnlyDirective,
						TemplateSerde::parse::<#ty>(#ron).unwrap()
					)}
				} else {
					quote! {TemplateSerde::parse::<#ty>(#ron).unwrap()}
				}
			});
			quote! {
					loader.try_mount(app, #route_info, |world| {
					#(world.spawn(#islands);)*
				});
			}
		});
		quote! {
			let loader = ClientIslandLoader::new();
			#(#islands)*
		}
	}
}


pub fn collect_client_island_plugin(
	mut query: Populated<
		(&mut CodegenFileSendit, &CollectClientIslandPlugin),
		Added<CollectClientIslandPlugin>,
	>,
) -> Result {
	for (mut codegen_file, collect_client_island_plugin) in query.iter_mut() {
		let client_island_map = ClientIslandMap::read(
			&collect_client_island_plugin.islands_map_path.into_abs(),
		)?;
		let islands_impl =
			CollectClientIslandPlugin::load_impl(&client_island_map);

		codegen_file.add_item::<syn::ItemStruct>(syn::parse_quote! {
			pub struct ClientIslandPlugin;
		});
		codegen_file.add_item::<syn::ItemImpl>(syn::parse_quote! {
			impl bevy::prelude::Plugin for ClientIslandPlugin {
				fn build(&self, app: &mut bevy::prelude::App) {
					#islands_impl
				}
			}
		});
	}
	Ok(())
}


#[cfg(test)]
mod test {
	use crate::prelude::*;
	use beet_common::prelude::*;
	use beet_net::prelude::*;
	use beet_router::prelude::*;
	use quote::quote;
	use serde::Serialize;
	use sweet::prelude::*;


	#[derive(Serialize)]
	struct Foo(pub u32);

	#[test]
	fn works() {
		let map = ClientIslandMap::new(vec![(RouteInfo::get("test"), vec![
			ClientIsland {
				template: TemplateSerde::new(&Foo(7)),
				tracker: RustyTracker {
					index: 0,
					tokens_hash: 0,
				},
				mount: true,
			},
			ClientIsland {
				template: TemplateSerde::new(&Foo(8)),
				tracker: RustyTracker {
					index: 1,
					tokens_hash: 100,
				},
				mount: false,
			},
		])]);

		CollectClientIslandPlugin::load_impl(&map)
			.to_string()
			.xpect()
			.to_be_str(
				quote! {
					let loader = ClientIslandLoader::new();
					loader.try_mount(
						app,
						RouteInfo {
							path: RoutePath(std::path::PathBuf::from("test")),
							method: HttpMethod::Get
						},
						|world| {
							world.spawn((
								ClientOnlyDirective,
								TemplateSerde::parse::<beet_build::client_island_codegen::collect_client_island_plugin::test::Foo>("(7)").unwrap()
							));
							world.spawn(
								TemplateSerde::parse::<beet_build::client_island_codegen::collect_client_island_plugin::test::Foo>("(8)").unwrap()
							);
						}
					);
				}
				.to_string(),
			);
	}
}
