use crate::prelude::*;
use beet_bevy::bevyhow;
use beet_common::prelude::TempNonSendMarker;
use beet_common::prelude::TokenizeSelf;
use bevy::prelude::*;
use heck::ToUpperCamelCase;
use proc_macro2::TokenStream;
use quote::quote;
use syn::parse_quote;


/// Call [`CodegenFile::add_item`] for every [`RouteFileMethod`] in the
/// [`RouteFile`] children.
pub fn collect_file_group(
	_: TempNonSendMarker,
	mut query: Populated<
		(&mut CodegenFileSendit, &FileGroupSendit, &Children),
		Added<FileGroupSendit>,
	>,
	route_files: Query<(&RouteFile, &Children)>,
	methods: Query<&RouteFileMethod>,
) -> Result {
	for (mut codegen_file, file_group, group_children) in query.iter_mut() {
		let mut route_infos = Vec::<TokenStream>::new();
		let mut route_handlers = Vec::<TokenStream>::new();
		let mut route_metas = Vec::<syn::Path>::new();
		let mut contains_file_meta = false;

		for (route_file, route_file_children) in group_children
			.iter()
			.filter_map(|child| route_files.get(child).ok())
		{
			codegen_file.add_item(route_file.item_mod(file_group.category));
			let mod_ident = route_file.mod_ident();

			for method in route_file_children
				.iter()
				.filter_map(|child| methods.get(child).ok())
			{
				let method_name =
					method.route_info.method.to_string_lowercase();

				if method.meta == RouteFileMethodMeta::FileGroup {
					contains_file_meta = true;
				}

				let http_method = quote::format_ident!("{method_name}",);
				let route_info = method.route_info.self_token_stream();
				let meta_ident = method.meta.ident(&mod_ident, &method_name);

				match file_group.category {
					FileGroupCategory::Pages => {
						// All page routes are BundleRoutes, so use add_bundle_route
						// for middleware support
						route_handlers.push(parse_quote! {
								router = plugin.add_bundle_route(
									router,
									#route_info,
									#mod_ident::#http_method,
									#meta_ident()
								);
						});
					}
					FileGroupCategory::Actions => {
						// Action routes may be any kind of route
						route_handlers.push(quote! {
								router = plugin.add_route(router,#route_info, #mod_ident::#http_method);
						});
					}
				}
				route_metas.push(meta_ident);
				route_infos.push(route_info);
			}
		}


		let group_name = if let Some(group_name) = &file_group.name {
			group_name.clone()
		} else {
			codegen_file
				.output
				.file_stem()
				.map(|name| name.to_string_lossy().to_string())
				.ok_or_else(|| bevyhow!("failed"))?
		};

		let router_plugin_ident =
			quote::format_ident!("{}Plugin", group_name.to_upper_camel_case());

		codegen_file.add_item::<syn::ItemStruct>(parse_quote! {
			#[derive(Debug, Default, Clone)]
			pub struct #router_plugin_ident;
		});

		let default_meta: Option<syn::ItemFn> = if contains_file_meta {
			Some(parse_quote! {
				/// The default meta for routes that do not have a specific
				/// meta defined.
				fn meta() -> <Self as RouterPlugin>::Meta {
					Default::default()
				}
			})
		} else {
			None
		};

		codegen_file.add_item::<syn::ItemImpl>(parse_quote! {
			#[cfg(not(target_arch = "wasm32"))]
			impl #router_plugin_ident {
				#default_meta
			}
		});
		let meta_ty = &file_group.meta_type;
		let router_state_type = &file_group.router_state_type;
		let is_static = file_group.category.include_in_route_tree();

		codegen_file.add_item::<syn::ItemImpl>(parse_quote! {
			#[cfg(not(target_arch = "wasm32"))]
			impl RouterPlugin for #router_plugin_ident {
				type State = #router_state_type;
				type Meta = #meta_ty;

				fn is_static(&self) -> bool {
					#is_static
				}

				fn routes(&self)-> Vec<RouteInfo> {
					vec![#(#route_infos),*]
				}

				fn meta(&self) -> Vec<Self::Meta> {
					vec![#(#route_metas()),*]
				}

				fn add_routes_with(&self,
					mut router: beet::exports::axum::Router<#router_state_type>,
					plugin: &impl RouterPlugin<State = Self::State, Meta = Self::Meta>,
				)
					-> beet::exports::axum::Router<#router_state_type> {
						#(#route_handlers)*
					router
				}
			}
		});
	}
	Ok(())
}


#[cfg(test)]
mod test {
	use crate::prelude::*;
	use beet_bevy::prelude::WorldMutExt;
	use beet_parse::prelude::ParseRsxTokensPlugin;
	use bevy::prelude::*;
	use quote::ToTokens;
	use sweet::prelude::*;

	#[test]
	fn works() {
		let mut app = App::new();
		app.add_plugins((RouteCodegenPlugin, ParseRsxTokensPlugin));
		app.world_mut().spawn(FileGroup::test_site_docs());
		app.update();
		app
			.world_mut()
			.query_filtered_once::<&CodegenFileSendit, With<FileGroupSendit>>()[0]
			.build_output()
			.unwrap()
			.to_token_stream()
			.to_string()
			.xpect()
			.to_be_str(quote::quote! {
				#![doc = r" ðŸŒ±ðŸŒ±ðŸŒ± This file has been auto generated by Beet."]
				#![doc = r" ðŸŒ±ðŸŒ±ðŸŒ± Any changes will be overridden if the file is regenerated."]
				#[allow(unused_imports)]
				use beet::prelude::*;
				#[allow(unused_imports)]
				use crate as test_site;
				#[path = "hello.rs"]
				pub mod route0;
				#[derive(Debug, Default, Clone)]
				pub struct TestDocsPlugin;
				#[cfg(not(target_arch = "wasm32"))]
				impl TestDocsPlugin {}
				#[cfg(not(target_arch = "wasm32"))]
				impl RouterPlugin for TestDocsPlugin {
					type State = ();
					type Meta = ();
					fn is_static(&self) -> bool {
						true
					}
					fn routes(&self) -> Vec<RouteInfo> {
						vec![RouteInfo {
							path: RoutePath(std::path::PathBuf::from("/hello")),
							method: HttpMethod::Get
						}]
					}
					fn meta(&self) -> Vec<Self::Meta> {
						vec![route0::meta()]
					}
					fn add_routes_with(
						&self,
						mut router: beet::exports::axum::Router<()>,
						plugin: &impl RouterPlugin<State = Self::State, Meta = Self::Meta>,
					) -> beet::exports::axum::Router<()> {
						router = plugin.add_bundle_route(
							router,
							RouteInfo {
								path: RoutePath(std::path::PathBuf::from("/hello")),
								method: HttpMethod::Get
							},
							route0::get,
							route0::meta()
						);
						router
					}
				}

			}.to_string());
	}
}
