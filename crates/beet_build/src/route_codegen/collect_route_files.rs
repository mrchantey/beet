use crate::prelude::*;
use beet_core::prelude::bevyhow;
use beet_common::prelude::TokenizeSelf;
use bevy::prelude::*;
use heck::ToUpperCamelCase;
use proc_macro2::TokenStream;
use quote::quote;
use syn::parse_quote;


/// Call [`CodegenFile::add_item`] for every [`RouteFileMethod`] in the
/// [`RouteFile`] children.
pub fn collect_route_files(
	mut query: Populated<
		(&mut CodegenFile, &RouteFileCollection, &Children),
		Changed<RouteFileCollection>,
	>,
	route_files: Query<(&RouteFile, &Children)>,
	methods: Query<&RouteFileMethod>,
) -> Result {
	for (mut codegen_file, collection, collection_children) in query.iter_mut()
	{
		let mut route_infos = Vec::<TokenStream>::new();
		let mut route_handlers = Vec::<TokenStream>::new();
		let mut route_metas = Vec::<syn::Path>::new();
		let mut contains_file_meta = false;

		for (route_file, route_file_children) in collection_children
			.iter()
			.filter_map(|child| route_files.get(child).ok())
		{
			codegen_file.add_item(route_file.item_mod(collection.category));
			let mod_ident = route_file.mod_ident();

			for method in route_file_children
				.iter()
				.filter_map(|child| methods.get(child).ok())
			{
				let method_name =
					method.route_info.method.to_string_lowercase();

				if method.meta == RouteFileMethodMeta::Collection {
					contains_file_meta = true;
				}

				let http_method = quote::format_ident!("{method_name}",);
				let route_info = method.route_info.self_token_stream();
				let meta_ident = method.meta.ident(&mod_ident, &method_name);

				match collection.category {
					RouteCollectionCategory::Pages => {
						// All page routes are BundleRoutes, so use add_bundle_route
						// for middleware support
						route_handlers.push(parse_quote! {
								router = plugin.add_bundle_route(
									router,
									#route_info,
									#mod_ident::#http_method,
									#meta_ident()
								);
						});
					}
					RouteCollectionCategory::Actions => {
						// Action routes may be any kind of route
						route_handlers.push(quote! {
								router = plugin.add_route(router,#route_info, #mod_ident::#http_method);
						});
					}
				}
				route_metas.push(meta_ident);
				route_infos.push(route_info);
			}
		}


		let collection_name = if let Some(name) = &collection.name {
			name.clone()
		} else {
			codegen_file
				.output
				.file_stem()
				.map(|name| name.to_string_lossy().to_string())
				.ok_or_else(|| bevyhow!("failed"))?
		};

		let router_plugin_ident = quote::format_ident!(
			"{}Plugin",
			collection_name.to_upper_camel_case()
		);

		codegen_file.add_item::<syn::ItemStruct>(parse_quote! {
			#[derive(Debug, Default, Clone)]
			pub struct #router_plugin_ident;
		});

		let default_meta: Option<syn::ItemFn> = if contains_file_meta {
			Some(parse_quote! {
				/// The default meta for routes that do not have a specific
				/// meta defined.
				fn meta() -> <Self as RouterPlugin>::Meta {
					Default::default()
				}
			})
		} else {
			None
		};

		codegen_file.add_item::<syn::ItemImpl>(parse_quote! {
			#[cfg(not(feature = "client"))]
			impl #router_plugin_ident {
				#default_meta
			}
		});
		let meta_ty = &collection.meta_type;
		let router_state_type = &collection.router_state_type;
		let is_static = collection.category.include_in_route_tree();

		codegen_file.add_item::<syn::ItemImpl>(parse_quote! {
			#[cfg(not(feature = "client"))]
			impl RouterPlugin for #router_plugin_ident {
				type State = #router_state_type;
				type Meta = #meta_ty;

				fn is_static(&self) -> bool {
					#is_static
				}

				fn routes(&self)-> Vec<RouteInfo> {
					vec![#(#route_infos),*]
				}

				fn meta(&self) -> Vec<Self::Meta> {
					vec![#(#route_metas()),*]
				}

				fn add_routes_with(&self,
					mut router: beet::exports::axum::Router<Self::State>,
					plugin: &impl RouterPlugin<State = Self::State, Meta = Self::Meta>,
				)
					-> beet::exports::axum::Router<Self::State> {
						#(#route_handlers)*
					router
				}
			}
		});
	}
	Ok(())
}


#[cfg(test)]
mod test {
	use crate::prelude::*;
	use beet_core::prelude::WorldMutExt;
	use beet_utils::prelude::*;
	use bevy::prelude::*;
	use quote::ToTokens;
	use sweet::prelude::*;

	#[test]
	fn works() {
		let mut app = App::new();
		app.add_plugins(BuildPlugin::without_fs());
		app.world_mut().spawn(SourceFile::new(
			WsPathBuf::new(
				"crates/beet_router/src/test_site/test_docs/hello.md",
			)
			.into_abs(),
		));
		app.world_mut().spawn(RouteFileCollection::test_site_docs());
		app.update();
		app
			.world_mut()
			.query_filtered_once::<&CodegenFile, With<RouteFileCollection>>()[0]
			.build_output()
			.unwrap()
			.to_token_stream()
			.to_string()
			.xpect()
			.to_be_str(quote::quote! {
				#![doc = r" ðŸŒ±ðŸŒ±ðŸŒ± This file has been auto generated by Beet."]
				#![doc = r" ðŸŒ±ðŸŒ±ðŸŒ± Any changes will be overridden if the file is regenerated."]
				#[allow(unused_imports)]
				use beet::prelude::*;
				#[allow(unused_imports)]
				use crate as test_site;
				#[path = "hello.rs"]
				pub mod route0;
				#[derive(Debug, Default, Clone)]
				pub struct TestDocsPlugin;
				#[cfg(not(feature = "client"))]
				impl TestDocsPlugin {}
				#[cfg(not(feature = "client"))]
				impl RouterPlugin for TestDocsPlugin {
					type State = AppRouterState;
					type Meta = ();
					fn is_static(&self) -> bool {
						true
					}
					fn routes(&self) -> Vec<RouteInfo> {
						vec![RouteInfo {
							path: RoutePath(std::path::PathBuf::from("/hello")),
							method: HttpMethod::Get
						}]
					}
					fn meta(&self) -> Vec<Self::Meta> {
						vec![route0::meta()]
					}
					fn add_routes_with(
						&self,
						mut router: beet::exports::axum::Router<Self::State>,
						plugin: &impl RouterPlugin<State = Self::State, Meta = Self::Meta>,
					) -> beet::exports::axum::Router<Self::State> {
						router = plugin.add_bundle_route(
							router,
							RouteInfo {
								path: RoutePath(std::path::PathBuf::from("/hello")),
								method: HttpMethod::Get
							},
							route0::get,
							route0::meta()
						);
						router
					}
				}

			}.to_string());
	}
}
