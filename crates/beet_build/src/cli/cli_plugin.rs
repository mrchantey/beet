use crate::prelude::*;
use beet_core::prelude::*;
use beet_flow::prelude::*;
use clap::Parser;

#[derive(Resource)]
pub struct ProjectMetadata {}

#[derive(Debug, Clone, Parser, Resource)]
pub struct CliConfig {
	/// The path to the file generated by the launch step
	#[arg(long, default_value = "launch.ron")]
	pub launch_file: WsPathBuf,
	/// Run the launch step even if the hashes match
	#[arg(long)]
	pub force_launch: bool,
	/// The package to run
	#[arg(short, long)]
	pub package: Option<String>,
	/// Additional cargo args to run for the launch step
	#[arg(long)]
	pub launch_cargo_args: Option<String>,
	/// Exclude the 'launch' feature, package name etc from the launch step
	#[arg(long)]
	pub launch_no_default_args: bool,
}

impl CliConfig {
	pub fn launch_step(&self) -> BuildStep {
		let mut args = Vec::new();
		if !self.launch_no_default_args {
			args.push("run".into());
			if let Some(package) = &self.package {
				args.push("--package".into());
				args.push(package.clone());
			}
			args.push("--features".into());
			args.push("launch".into());
		}
		if let Some(launch_cargo_args) = &self.launch_cargo_args {
			args.extend(launch_cargo_args.split_whitespace().map(|s| s.into()));
		}

		BuildStep {
			cmd: "cargo".into(),
			args,
		}
	}
}

pub fn launch_cmd() {}

pub struct CliPlugin;

impl Plugin for CliPlugin {
	fn build(&self, app: &mut App) {
		app.add_plugins((ControlFlowPlugin, BuildPlugin))
			.add_systems(Startup, (load_launch_file, run_pipeline).chain());
	}
}
