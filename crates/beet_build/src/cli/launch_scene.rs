//! The launch scene is a file generated by the launch step of an application,
//! containing configuration for all codegen and build steps.
//! It is usually located at `launch.ron` but this can be configured in the cli.
use crate::prelude::*;
use beet_core::prelude::*;
use beet_dom::prelude::IntoBundle;
use beet_flow::prelude::*;
use rapidhash::RapidHasher;
use std::hash::Hasher;

#[derive(Resource)]
pub struct LaunchState {
	/// The hash of the last [`watched_files`](Self::watched_files)
	last_hash: u64,
	/// A list of rust files that will trigger the launch
	/// process if changed, ie `["src/launch.rs"]`
	watched_files: Vec<WsPathBuf>,
}

#[rustfmt::skip]
pub fn launch_sequence(config: Res<CliConfig>) -> impl Bundle {
	(
		InfallibleSequence,
		children![(
			Sequence,
			// Run launch to generate scene if needed
			children![
				OnSpawn::observe(launch_step_predicate),
				config.launch_step().into_bundle()
			]),
			// load launch scene into world
			// regardless of whether we needed to run the launch step
			OnSpawn::observe(load_launch_scene)
		]
	)
}

fn load_launch_scene(mut ev: On<GetOutcome>, world: &mut World) -> Result {
	let config = world.resource::<CliConfig>();
	// missing scene is an error at this stage
	let scene = fs_ext::read_to_string(&config.launch_file)?;
	world.load_scene(&scene)?;

	ev.trigger_with_cx(Outcome::Pass);
	Ok(())
}

/// Whether to run the launch step, only false if hashes match
/// and !force_lanch
fn launch_step_predicate(
	mut ev: On<GetOutcome>,
	config: Res<CliConfig>,
	type_registry: Res<AppTypeRegistry>,
) -> Result<()> {
	if config.force_launch {
		ev.trigger_with_cx(Outcome::Pass);
		return Ok(());
	}
	let Ok(scene) = fs_ext::read_to_string(&config.launch_file) else {
		// no scene, should run
		ev.trigger_with_cx(Outcome::Pass);
		return Ok(());
	};
	// create a temp world to extract the LaunchState from the launch scene
	let mut temp_world = World::new();
	temp_world.insert_resource(type_registry.clone());
	temp_world.load_scene(scene)?;
	let Some(launch_state) = temp_world.get_resource::<LaunchState>() else {
		bevybail!(
			"LaunchState is missing from launch scene, this can happen if it was not generated by the cli"
		);
	};

	let current_hash = hash_paths(&launch_state.watched_files)?;
	let outcome = if current_hash == launch_state.last_hash {
		// hashes match, do nothing
		Outcome::Fail
	} else {
		// run launch step if no match
		Outcome::Pass
	};
	ev.trigger_with_cx(outcome);
	Ok(())
}


fn hash_paths(paths: &Vec<WsPathBuf>) -> Result<u64> {
	let mut hash = RapidHasher::default_const();
	for path in paths {
		let path = path.into_abs();
		let bytes = fs_ext::read(&path)?;
		hash.write(&bytes);
	}
	Ok(hash.finish())
}
