use crate::prelude::*;
use beet_bevy::bevyhow;
use beet_common::Sendit;
use beet_common::as_beet::*;
use beet_parse::prelude::tokenize_bundle;
use bevy::prelude::*;
use quote::quote;
use syn::Block;
use syn::Expr;
use syn::ItemFn;

/// Added to the root of route files that have been parsed into a tree via
/// [`CombinatorTokens`], ie `.md` and `.rsx` files.
#[derive(Debug, Clone, Sendit)]
#[sendit(derive(Component))]
pub struct TemplateWrapper(pub Expr);

/// After a [`CombinatorTokens`] has been parsed into a [`Bundle`],
/// tokenize it and append to the [`CodegenFile`].
pub fn tokenize_combinator_route(world: &mut World) -> Result {
	let mut query =
		world.query_filtered::<Entity, (
			With<CodegenFileSendit>,
			Added<CombinatorRouteCodegenSendit>
		)>();
	let mut parents = world.query::<&ChildOf>();
	for entity in query.iter(world).collect::<Vec<_>>() {
		let mut tokens = tokenize_bundle(world, entity)?;
		trace!("Tokenizing combinator route for entity: {:?}", entity);

		if let Some(template_wrapper) = parents
			.query(world)
			.iter_ancestors(entity)
			.find_map(|e| world.get::<TemplateWrapperSendit>(e))
		{
			let template = &template_wrapper.0.0;
			tokens = quote::quote! {rsx!{
				<#template meta=meta()>
					#tokens
				</#template>
			}};
		}


		world
			.entity_mut(entity)
			.get_mut::<CodegenFileSendit>()
			.unwrap() // checked in query filter
			.add_item::<ItemFn>(syn::parse_quote!(
				pub fn get() -> impl Bundle{
					#tokens
				}
			));
	}
	Ok(())
}


/// Added to the root of route files that have been parsed into a tree via
/// [`CombinatorTokens`], ie `.md` and `.rsx` files.
#[derive(Debug, Clone, Sendit)]
#[sendit(derive(Component))]
pub struct CombinatorRouteCodegen {
	/// Optional metadata, this is the frontmatter of markdown files
	pub meta: Option<Block>,
}

/// insert the config function into the codegen file if it exists
pub fn collect_combinator_route(
	_: TempNonSendMarker,
	mut query: Populated<
		(
			Entity,
			&mut CodegenFileSendit,
			&CombinatorRouteCodegenSendit,
		),
		Added<CombinatorRouteCodegenSendit>,
	>,
	parents: Query<&ChildOf>,
	file_groups: Query<&FileGroupSendit>,
) -> Result {
	for (entity, mut codegen_file, combinator_codegen) in query.iter_mut() {
		let file_group = parents
			.iter_ancestors(entity)
			.find_map(|e| file_groups.get(e).ok())
			.ok_or_else(|| bevyhow!("failed to find parent FileGroup"))?;
		let meta_block = match &combinator_codegen.meta {
			Some(meta) => quote! {
				#meta.map_err(|err|{
					format!("Failed to parse meta: {}", err)
				}).unwrap()
			},
			None => quote!(Default::default()),
		};
		let meta_type = &file_group.meta_type;
		codegen_file.add_item::<ItemFn>(syn::parse_quote!(
			pub fn meta()-> #meta_type{
				#meta_block
			}
		));
	}
	Ok(())
}



#[cfg(test)]
mod test {
	use crate::prelude::*;
	use beet_bevy::prelude::WorldMutExt;
	use beet_parse::prelude::NodeTokensPlugin;
	use bevy::prelude::*;
	use quote::ToTokens;
	use quote::quote;
	use sweet::prelude::*;

	#[test]
	fn works() {
		let mut app = App::new();
		app.add_plugins((RouterCodegenPlugin, NodeTokensPlugin));
		app.world_mut().spawn((
			FileGroup::test_site_docs(),
			TemplateWrapper(syn::parse_quote!(MyWrapperNode)).sendit(),
		));
		app.update();
		app
		.world_mut()
		.query_filtered_once::<&CodegenFileSendit, With<CombinatorRouteCodegenSendit>>(
		)[0]
		.build_output()
		.unwrap()
		.to_token_stream()
		.to_string().xpect().to_be_str(quote!{
			#![doc = r" ðŸŒ±ðŸŒ±ðŸŒ± This file has been auto generated by Beet."]
			#![doc = r" ðŸŒ±ðŸŒ±ðŸŒ± Any changes will be overridden if the file is regenerated."]
			#[allow(unused_imports)]
			use beet::prelude::*;
			#[allow(unused_imports)]
			use crate as test_site;

			pub fn meta() -> () {
				{
					beet::exports::toml::from_str("title = \"hello\"\n[sidebar]\norder = 2\n")
				}
				.map_err(|err| {
					format!("Failed to parse meta: {}", err)
				})
				.unwrap()
			}

			pub fn get() -> impl Bundle {
				rsx! {
					<MyWrapperNode meta={meta()}>
					{
						(
							FragmentNode,
							related! {
								Children [
									(
										NodeTag(String::from("h1")),
										ElementNode { self_closing: false },
										related! {
											Children [
												TextNode(String::from("Hello"))
											]
										}
									),
									(
										NodeTag(String::from("p")),
										ElementNode { self_closing: false },
										related! {
											Children [
												TextNode(String::from("This page is all about saying hello"))
											]
										}
									),
									(
										NodeTag(String::from("MyComponent")),
										FragmentNode,
										TemplateNode,
										ItemOf::<TemplateNode, RustyTracker> {
											value: RustyTracker {
												index: 0u32,
												tokens_hash: 15709703891249699336u64
											},
											phantom: std::marker::PhantomData::<TemplateNode>
										},
										{
											let template = <MyComponent as Props>::Builder::default()
												.val({ 2 + 2 })
												.build();
											#[allow(unused_braces)]
											(TemplateRoot::spawn(Spawn(template.into_node_bundle())))
										},
										related! {
											Children [
												TextNode(String::from("## RSX\n\tIt contains some rsx, not sure if this will work"))
											]
										}
									)
								]
							}
						)
					}
					</MyWrapperNode>
				}
			}
	}.to_string());
	}
}
