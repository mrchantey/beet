use crate::prelude::*;
use anyhow::Result;
use beet_core::prelude::*;
use bevy::prelude::*;
use heck::ToSnakeCase;
use serde::Deserialize;
use serde::Serialize;
use syn::Expr;
use syn::Item;


/// Call [`CodegenFile::build_and_write`] for every [`Changed<CodegenFile>`]
pub fn export_codegen(
	query: Populated<&CodegenFile, Changed<CodegenFile>>,
) -> bevy::prelude::Result {
	let num_files = query.iter().count();
	info!("Exporting {} codegen files...", num_files);
	for codegen_file in query.iter() {
		codegen_file.build_and_write()?;
	}
	Ok(())
}


/// Every codegen file is created via this struct. It contains
/// several utilities and standards that make the whole thing nicer.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Component)]
pub struct CodegenFile {
	/// The output codegen file location.
	pub output: AbsPathBuf,
	/// All of the imports that must be included both globally and inside each
	/// inline module.
	/// These will not be erased when the file is regenerated.
	#[serde(
		default = "default_imports",
		rename = "import_tokens",
		with = "syn_item_vec_serde"
	)]
	pub imports: Vec<Unspan<Item>>,
	/// As [`std::any::type_name`], which is used with [`TemplateSerde`], resolves to a named crate, we need to alias the current
	/// crate to match any internal types, setting this option will add `use crate as pkg_name`
	/// to the top of the file.
	#[serde(default, rename = "package_name")]
	pub pkg_name: Option<String>,
	// List of all root level items to be included in the file.
	// These are usually appended to as this struct is passed around.
	#[serde(default, with = "syn_item_vec_serde")]
	pub items: Vec<Unspan<Item>>,
}

fn default_imports() -> Vec<Unspan<Item>> {
	vec![Unspan::new(&syn::parse_quote!(
		#[allow(unused_imports)]
		use beet::prelude::*;
	))]
}

impl Default for CodegenFile {
	fn default() -> Self {
		Self {
			imports: default_imports(),
			output: WsPathBuf::new("src/codegen/mod.rs").into_abs(),
			pkg_name: None,
			items: Default::default(),
		}
	}
}

impl CodegenFile {
	/// Create a new [`CodegenFile`] with the most common options.
	pub fn new(output: AbsPathBuf) -> Self {
		Self {
			output,
			..Default::default()
		}
	}

	pub fn name(&self) -> String {
		match self
			.output
			.file_stem()
			.expect("codegen output must have a file stem")
			.to_str()
			.expect("file stem must be valid UTF-8")
		{
			"mod" => self
				.output
				.parent()
				.expect("mod files must have a parent")
				.file_name()
				.expect("parent must have a file name")
				.to_str()
				.expect("file name must be valid UTF-8")
				.to_owned(),
			other => other.to_owned(),
		}
		.to_snake_case()
	}

	/// Clone the metadata of this codegen file, but change the output path
	/// and clears the items.
	pub fn clone_info(&self, output: AbsPathBuf) -> Self {
		Self {
			output,
			imports: self.imports.clone(),
			pkg_name: self.pkg_name.clone(),
			items: Vec::new(),
		}
	}

	pub fn with_pkg_name(mut self, pkg_name: impl Into<String>) -> Self {
		self.pkg_name = Some(pkg_name.into());
		self
	}

	pub fn with_import(mut self, item: Item) -> Self {
		self.imports.push(Unspan::new(&item));
		self
	}
	/// Set the imports for this codegen file, replacing the default and a
	/// previously set imports.
	pub fn set_imports(mut self, items: Vec<Item>) -> Self {
		self.imports = items.iter().map(Unspan::new).collect();
		self
	}


	pub fn output_dir(&self) -> Result<AbsPathBuf> {
		self.output.parent().ok_or_else(|| {
			anyhow::anyhow!("Output path must have a parent directory")
		})
	}
	pub fn clear_items(&mut self) { self.items.clear(); }

	pub fn add_item<T: Into<syn::Item>>(&mut self, item: T) {
		self.items.push(Unspan::new(&item.into()));
	}

	pub fn build_output(&self) -> Result<syn::File> {
		let imports = &self.imports;
		let crate_alias = self.crate_alias()?;

		let items = &self.items;

		Ok(syn::parse_quote! {
			//! ðŸŒ±ðŸŒ±ðŸŒ± This file has been auto generated by Beet.
			//! ðŸŒ±ðŸŒ±ðŸŒ± Any changes will be overridden if the file is regenerated.
			#(#imports)*
			#crate_alias
			#(#items)*
		})
	}

	/// Builds the output file and writes it to the specified path
	/// if it has changed.
	pub fn build_and_write(&self) -> Result<()> {
		let output_tokens = self.build_output()?;
		// ideally we'd use rustfmt instead
		let output_str = prettyplease::unparse(&output_tokens);
		trace!("Exporting codegen file:\n{}", self.output.to_string_lossy());

		FsExt::write_if_diff(&self.output, &output_str)?;
		Ok(())
	}

	// this is legacy from when client islands use std::any::type_name
	// we can remove it after scenes-as-islands
	fn crate_alias(&self) -> Result<Option<syn::Item>> {
		if let Some(pkg_name) = &self.pkg_name {
			let pkg_name: Expr = syn::parse_str(pkg_name)?;
			Ok(Some(syn::parse_quote! {
				#[allow(unused_imports)]
				use crate as #pkg_name;
			}))
		} else {
			Ok(None)
		}
	}
}



#[cfg(test)]
mod test {
	use crate::prelude::*;
	use quote::ToTokens;
	use sweet::prelude::*;
	use syn::ItemFn;

	#[test]
	fn works() {
		let mut file = CodegenFile::default();
		file.add_item::<ItemFn>(syn::parse_quote! {
			fn test() {}
		});
		(&file.build_output().unwrap().to_token_stream().to_string())
			.xpect_contains("fn test () { }");
	}
}
