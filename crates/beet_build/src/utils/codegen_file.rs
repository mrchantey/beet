use crate::prelude::*;
use anyhow::Result;
use beet_common::as_beet::*;
use beet_parse::exports::SendWrapper;
use beet_parse::prelude::ParseRsxTokensSet;
use beet_template::prelude::*;
use beet_utils::prelude::*;
use bevy::prelude::*;
use serde::Deserialize;
use serde::Serialize;
use syn::Expr;
use syn::Item;



/// System set for exporting codegen files, Static Trees, Lang Partials, etc.
/// This set should be configured to run after all importing and processing.
#[derive(Debug, Clone, PartialEq, Eq, Hash, SystemSet)]
pub struct ExportArtifactsSet;

#[derive(Debug, Default)]
pub struct ExportArtifactsPlugin;


impl Plugin for ExportArtifactsPlugin {
	fn build(&self, app: &mut App) {
		app
			.configure_sets(
				Update,
				ExportArtifactsSet
					.after(ParseRsxTokensSet)
					.before(TemplateSet),
			)
			.add_systems(
				Update,
				export_codegen_files.in_set(ExportArtifactsSet),
			);
	}
}

/// Call [`CodegenFile::build_and_write`] for every [`Added`] [`CodegenFileSendit`]
fn export_codegen_files(
	_: TempNonSendMarker,
	query: Populated<&CodegenFileSendit, Added<CodegenFileSendit>>,
) -> bevy::prelude::Result {
	let num_files = query.iter().count();
	info!("Exporting {} codegen files...", num_files);
	for codegen_file in query.iter() {
		trace!(
			"Exporting codegen file:\n{}",
			codegen_file.output.to_string_lossy()
		);
		codegen_file.build_and_write()?;
	}
	Ok(())
}

/// Every codegen file is created via this struct. It contains
/// several utilities and standards that make the whole thing nicer.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Sendit)]
#[sendit(derive(Component))]
pub struct CodegenFile {
	/// The output codegen file location.
	pub output: AbsPathBuf,
	/// All of the imports that must be included both globally and inside each
	/// inline module.
	#[serde(
		default = "default_imports",
		rename = "import_tokens",
		with = "syn_item_vec_serde"
	)]
	pub imports: Vec<Item>,
	/// As [`std::any::type_name`], which is used with [`TemplateSerde`], resolves to a named crate, we need to alias the current
	/// crate to match any internal types, setting this option will add `use crate as pkg_name`
	/// to the top of the file.
	#[serde(default, rename = "package_name")]
	pub pkg_name: Option<String>,
	// List of all root level items to be included in the file.
	// These are usually appended to as this struct is passed around.
	#[serde(default, with = "syn_item_vec_serde")]
	pub items: Vec<Item>,
}

impl Default for CodegenFileSendit {
	fn default() -> Self { Self(SendWrapper::new(CodegenFile::default())) }
}

fn default_imports() -> Vec<Item> {
	vec![syn::parse_quote!(
		#[allow(unused_imports)]
		use beet::prelude::*;
	)]
}

impl Default for CodegenFile {
	fn default() -> Self {
		Self {
			imports: default_imports(),
			output: WsPathBuf::new("src/codegen/mod.rs").into_abs(),
			pkg_name: None,
			items: Default::default(),
		}
	}
}

impl CodegenFile {
	/// Create a new [`CodegenFile`] with the most common options.
	pub fn new(output: AbsPathBuf) -> Self {
		Self {
			output,
			..Default::default()
		}
	}

	/// Clone the metadata of this codegen file, but change the output path
	/// and clears the items.
	pub fn clone_info(&self, output: AbsPathBuf) -> Self {
		Self {
			output,
			imports: self.imports.clone(),
			pkg_name: self.pkg_name.clone(),
			items: Vec::new(),
		}
	}

	pub fn with_pkg_name(mut self, pkg_name: impl Into<String>) -> Self {
		self.pkg_name = Some(pkg_name.into());
		self
	}

	pub fn with_import(mut self, item: Item) -> Self {
		self.imports.push(item);
		self
	}


	pub fn output_dir(&self) -> Result<AbsPathBuf> {
		self.output.parent().ok_or_else(|| {
			anyhow::anyhow!("Output path must have a parent directory")
		})
	}

	pub fn add_item<T: Into<syn::Item>>(&mut self, item: T) {
		self.items.push(item.into());
	}

	pub fn build_output(&self) -> Result<syn::File> {
		let imports = &self.imports;
		let crate_alias = self.crate_alias()?;

		let items = &self.items;

		Ok(syn::parse_quote! {
			//! ðŸŒ±ðŸŒ±ðŸŒ± This file has been auto generated by Beet.
			//! ðŸŒ±ðŸŒ±ðŸŒ± Any changes will be overridden if the file is regenerated.
			#(#imports)*
			#crate_alias
			#(#items)*
		})
	}

	pub fn build_and_write(&self) -> Result<()> {
		let output_tokens = self.build_output()?;
		// ideally we'd use rustfmt instead
		let output_str = prettyplease::unparse(&output_tokens);

		FsExt::write_if_diff(&self.output, &output_str)?;
		Ok(())
	}
	fn crate_alias(&self) -> Result<Option<syn::Item>> {
		if let Some(pkg_name) = &self.pkg_name {
			let pkg_name: Expr = syn::parse_str(pkg_name)?;
			Ok(Some(syn::parse_quote! {
				#[allow(unused_imports)]
				use crate as #pkg_name;
			}))
		} else {
			Ok(None)
		}
	}
}



#[cfg(test)]
mod test {
	use crate::prelude::*;
	use quote::ToTokens;
	use sweet::prelude::*;
	use syn::ItemFn;

	#[test]
	fn works() {
		let mut file = CodegenFile::default();
		file.add_item::<ItemFn>(syn::parse_quote! {
			fn test() {}
		});
		expect(&file.build_output().unwrap().to_token_stream().to_string())
			.to_contain("fn test () { }");
	}
}
