use crate::prelude::*;
use beet_core::prelude::*;
use beet_flow::prelude::*;
use clap::Parser;

#[derive(Resource)]
pub struct ProjectMetadata {}

#[derive(Debug, Clone, Parser, Resource)]
pub struct CliConfig {
	/// The name of the pipeline to run, as defined in the launch step
	#[arg(long)]
	pub pipeline: Option<String>,
	/// The path to the file generated by the launch step
	#[arg(long, default_value = "launch.ron")]
	pub launch_file: WsPathBuf,
	/// Run the launch step even if the hashes match
	#[arg(long)]
	pub force_launch: bool,
	/// The package to run
	#[arg(short, long)]
	pub package: Option<String>,
	/// Additional cargo args to run for the launch step
	#[arg(long)]
	pub launch_cargo_args: Option<String>,
	/// Exclude the 'launch' feature, package name etc from the launch step
	#[arg(long)]
	pub launch_no_default_args: bool,
}

impl Default for CliConfig {
	fn default() -> Self { Self::parse_from(&[""]) }
}

impl CliConfig {
	pub fn launch_step(&self) -> TerminalCommand {
		let mut args = Vec::new();
		if !self.launch_no_default_args {
			args.push("run".into());
			if let Some(package) = &self.package {
				args.push("--package".into());
				args.push(package.clone());
			}
			args.push("--features".into());
			args.push("launch".into());
		}
		if let Some(launch_cargo_args) = &self.launch_cargo_args {
			args.extend(launch_cargo_args.split_whitespace().map(|s| s.into()));
		}

		TerminalCommand {
			cmd: "cargo".into(),
			args,
		}
	}
}

pub fn launch_cmd() {}

pub struct CliPlugin;

impl Plugin for CliPlugin {
	fn build(&self, app: &mut App) {
		app.add_plugins((ControlFlowPlugin, BuildPlugin));

		todo!("bsx");
		// app.world_mut()
		// 	.spawn(OnSpawn::run_insert(launch_sequence))
		// 	.trigger_target(GetOutcome);
	}
}
