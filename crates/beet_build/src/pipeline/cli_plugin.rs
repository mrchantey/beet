use crate::prelude::*;
use beet_core::prelude::*;
use beet_router::prelude::*;
use beet_rsx::prelude::*;
use clap::Parser;

#[derive(Resource)]
pub struct ProjectMetadata {}

#[derive(Debug, Clone, Parser, Resource)]
pub struct CliConfig {
	/// The name of the pipeline to run, as defined in the launch step
	#[arg(long)]
	pub pipeline: Option<String>,
	/// The path to the file generated by the launch step
	#[arg(long, default_value = "launch.ron")]
	pub launch_file: WsPathBuf,
	/// Run the launch step even if the hashes match
	#[arg(long)]
	pub force_launch: bool,
	/// The package to run
	#[arg(short, long)]
	pub package: Option<String>,
	/// Additional cargo args to run for the launch step
	#[arg(long)]
	pub launch_cargo_args: Option<String>,
	/// Exclude the 'launch' feature, package name etc from the launch step
	#[arg(long)]
	pub launch_no_default_args: bool,
}

impl Default for CliConfig {
	fn default() -> Self { Self::parse_from(&[""]) }
}

impl CliConfig {
	pub fn launch_step(&self) -> TerminalCommand {
		let mut args = Vec::new();
		if !self.launch_no_default_args {
			args.push("run".into());
			if let Some(package) = &self.package {
				args.push("--package".into());
				args.push(package.clone());
			}
			args.push("--features".into());
			args.push("launch".into());
		}
		if let Some(launch_cargo_args) = &self.launch_cargo_args {
			args.extend(launch_cargo_args.split_whitespace().map(|s| s.into()));
		}

		TerminalCommand {
			cmd: "cargo".into(),
			args,
		}
	}
}

pub fn launch_cmd() {}

#[derive(Default)]
pub struct CliPlugin;

impl Plugin for CliPlugin {
	fn build(&self, app: &mut App) { app.init_plugin::<RouterPlugin>(); }
}

#[construct]
pub fn CliRouter() -> Result<impl Bundle> {
	Ok((Router, OnSpawn::new_async(handler)))
}

async fn handler(entity: AsyncEntity) -> Result {
	let req = CliArgs::parse_env().into_request()?;
	let res = flow_route_handler(entity, req).await.into_result().await?;
	let body = res.body.into_string().await?;
	body.xprint();
	Ok(())
}
