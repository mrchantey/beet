use crate::prelude::*;
use beet_core::prelude::*;
use beet_router::prelude::*;
use clap::Parser;

#[derive(Resource)]
pub struct ProjectMetadata {}

#[derive(Debug, Clone, Parser, Resource)]
pub struct CliConfig {
	/// The path to the file generated by the launch step
	#[arg(long, default_value = "beet.ron")]
	pub beet_file: WsPathBuf,
	/// Run the launch step even if the hashes match
	#[arg(long)]
	pub force_launch: bool,
	/// The package to run when generating a beet file
	#[arg(short, long)]
	pub package: Option<String>,
	/// Additional cargo args to run for the launch step
	#[arg(long)]
	pub launch_cargo_args: Option<String>,
	/// Exclude the 'launch' feature, package name etc from the launch step
	#[arg(long)]
	pub launch_no_default_args: bool,
}

impl Default for CliConfig {
	fn default() -> Self { Self::parse_from(&[""]) }
}

impl CliConfig {
	pub fn launch_step(&self) -> ChildProcess {
		let mut args = Vec::new();
		if !self.launch_no_default_args {
			args.push("run".into());
			if let Some(package) = &self.package {
				args.push("--package".into());
				args.push(package.clone());
			}
			args.push("--features".into());
			args.push("launch".into());
		}
		if let Some(launch_cargo_args) = &self.launch_cargo_args {
			args.extend(launch_cargo_args.split_whitespace().map(|s| s.into()));
		}

		ChildProcess {
			cmd: "cargo".into(),
			args,
			..default()
		}
	}
}

pub fn launch_cmd() {}

#[derive(Default)]
pub struct CliPlugin;

impl Plugin for CliPlugin {
	fn build(&self, app: &mut App) {
		app.init_plugin::<RouterPlugin>()
			.insert_resource(CargoManifest::load().unwrap())
			// temp: hardcoded until bevy scene overhaul
			.insert_resource(PackageConfig {
				title: "Beet".into(),
				binary_name: "beet_site".into(),
				version: "0.0.8-dev.9".into(),
				description: "The beet website, built with beet".into(),
				homepage: "https://beetstack.dev".into(),
				repository: Some("https://github.com/mrchantey/beet".into()),
				stage: "dev".into(),
				service_access: ServiceAccess::Local,
			});
	}
}
