use crate::prelude::*;
use beet_core::prelude::*;
use beet_dom::prelude::IntoBundle;
use beet_flow::prelude::*;
use rapidhash::RapidHasher;
use std::hash::Hasher;

/// Indicates this scene is was generated by the launch step of an application,
/// containing configuration for all codegen and build steps.
/// It is usually located at `beet.ron` but this can be configured in the cli.
/// By default the `src/launch.rs` is watched, this can be extended if more files should be watched.
#[derive(Resource)]
pub struct BeetFile {
	/// The hash of the [`watched_files`](Self::watched_files) at the time
	/// this state was generated.
	hash: u64,
	/// A list of rust files that will trigger the launch
	/// process if changed, ie `src/launch.rs`
	watched_files: Vec<WsPathBuf>,
}
impl Default for BeetFile {
	fn default() -> Self {
		Self::new().expect("Failed to create default LaunchState")
	}
}


impl BeetFile {
	pub fn new() -> Result<Self> {
		let watched_files = vec![WsPathBuf::new("src/launch.rs")];
		let hash = hash_paths(&watched_files)?;
		Ok(Self {
			hash,
			watched_files,
		})
	}
}


#[rustfmt::skip]
pub fn launch_sequence(config: Res<CliConfig>) -> impl Bundle {
	(
		InfallibleSequence,
		children![(
			Sequence,
			// Run launch to generate scene if needed
			children![
				OnSpawn::observe(launch_step_predicate),
				config.launch_step().into_bundle()
			]),
			// load beet file into world
			// regardless of whether we needed to run the launch step
			OnSpawn::observe(load_launch_scene)
		]
	)
}

fn load_launch_scene(mut ev: On<GetOutcome>, world: &mut World) -> Result {
	let config = world.resource::<CliConfig>();
	// missing scene is an error at this stage
	let scene = fs_ext::read_to_string(&config.beet_file)?;
	world.load_scene(&scene)?;

	ev.trigger_with_cx(Outcome::Pass);
	Ok(())
}

/// Whether to run the launch step, only false if hashes match
/// and !force_lanch
fn launch_step_predicate(
	mut ev: On<GetOutcome>,
	config: Res<CliConfig>,
	type_registry: Res<AppTypeRegistry>,
) -> Result<()> {
	if config.force_launch {
		ev.trigger_with_cx(Outcome::Pass);
		return Ok(());
	}
	let Ok(scene) = fs_ext::read_to_string(&config.beet_file) else {
		// no scene, should run
		ev.trigger_with_cx(Outcome::Pass);
		return Ok(());
	};
	// create a temp world to extract the LaunchState from the beet file
	let mut temp_world = World::new();
	temp_world.insert_resource(type_registry.clone());
	temp_world.load_scene(scene)?;
	let Some(launch_state) = temp_world.get_resource::<BeetFile>() else {
		bevybail!(
			"LaunchState is missing from beet file, this can happen if it was not generated by the cli"
		);
	};

	let current_hash = hash_paths(&launch_state.watched_files)?;
	let outcome = if current_hash == launch_state.hash {
		// hashes match, do nothing
		Outcome::Fail
	} else {
		// run launch step if no match
		Outcome::Pass
	};
	ev.trigger_with_cx(outcome);
	Ok(())
}


fn hash_paths(paths: &Vec<WsPathBuf>) -> Result<u64> {
	let mut hash = RapidHasher::default_const();
	for path in paths {
		let path = path.into_abs();
		let bytes = fs_ext::read(&path)?;
		hash.write(&bytes);
	}
	Ok(hash.finish())
}
