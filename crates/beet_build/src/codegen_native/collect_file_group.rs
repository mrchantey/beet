use crate::prelude::*;
use beet_bevy::bevyhow;
use beet_common::prelude::TempNonSendMarker;
use beet_common::prelude::TokenizeSelf;
use bevy::prelude::*;
use heck::ToUpperCamelCase;
use proc_macro2::TokenStream;
use syn::parse_quote;


/// Call [`CodegenFile::add_item`] for every [`RouteFileMethod`] in the
/// [`RouteFile`] children.
pub fn collect_file_group(
	_: TempNonSendMarker,
	mut query: Populated<
		(&mut CodegenFileSendit, &FileGroupSendit, &Children),
		Added<FileGroupSendit>,
	>,
	route_files: Query<(&RouteFile, &Children)>,
	methods: Query<&RouteFileMethod>,
) -> Result {
	for (mut codegen_file, file_group, file_group_children) in query.iter_mut()
	{
		let mut route_infos = Vec::<TokenStream>::new();
		let mut route_handlers = Vec::<syn::Expr>::new();
		let mut route_metas = Vec::<syn::Path>::new();
		let mut contains_file_meta = false;

		for (route_file, route_file_children) in file_group_children
			.iter()
			.filter_map(|child| route_files.get(child).ok())
		{
			codegen_file.add_item(route_file.item_mod());
			let mod_ident = route_file.mod_ident();

			for method in route_file_children
				.iter()
				.filter_map(|child| methods.get(child).ok())
			{
				let method_name =
					method.route_info.method.to_string_lowercase();

				if method.meta == RouteFileMethodMeta::FileGroup {
					contains_file_meta = true;
				}

				let http_method = quote::format_ident!("{method_name}",);
				let route_info = method.route_info.self_token_stream();
				route_metas.push(method.meta.ident(&mod_ident, &method_name));
				route_handlers.push(parse_quote!(
					(#route_info, #mod_ident::#http_method)
				));
				route_infos.push(route_info);
			}
		}


		let group_name = if let Some(group_name) = &file_group.group_name {
			group_name.clone()
		} else {
			codegen_file
				.output
				.file_stem()
				.map(|name| name.to_string_lossy().to_string())
				.ok_or_else(|| bevyhow!("failed"))?
		};

		let router_plugin_ident =
			quote::format_ident!("{}Plugin", group_name.to_upper_camel_case());

		codegen_file.add_item::<syn::ItemStruct>(parse_quote! {
			#[derive(Debug, Default, Clone)]
			pub struct #router_plugin_ident;
		});

		let default_meta: Option<syn::ItemFn> = if contains_file_meta {
			Some(parse_quote! {
				/// The default meta for routes that do not have a specific
				/// meta defined.
				fn meta() -> <Self as RouterPlugin>::Meta {
					Default::default()
				}
			})
		} else {
			None
		};

		codegen_file.add_item::<syn::ItemImpl>(parse_quote! {
			impl #router_plugin_ident {
				#default_meta
			}
		});
		let meta_ty = &file_group.meta_type;
		let router_state_type = &file_group.router_state_type;
		codegen_file.add_item::<syn::ItemImpl>(parse_quote! {
			impl RouterPlugin for #router_plugin_ident {
				type State = #router_state_type;
				type Meta = #meta_ty;

				fn routes(&self)-> Vec<RouteInfo> {
					vec![#(#route_infos),*]
				}

				fn meta(&self) -> Vec<Self::Meta> {
					vec![#(#route_metas()),*]
				}

				fn build(self, mut router: beet::exports::axum::Router<#router_state_type>)
					-> beet::exports::axum::Router<#router_state_type> {
					#(router = self.add_route(router, #route_handlers);)*
					router
				}
			}
		});
	}
	Ok(())
}


#[cfg(test)]
mod test {
	use crate::prelude::*;
	use beet_bevy::prelude::WorldMutExt;
	use beet_parse::prelude::NodeTokensPlugin;
	use bevy::prelude::*;
	use quote::ToTokens;
	use sweet::prelude::*;

	#[test]
	fn works() {
		let mut app = App::new();
		app.add_plugins((CodegenNativePlugin, NodeTokensPlugin));
		app.world_mut().spawn(FileGroup::test_site_docs());
		app.update();
		app
			.world_mut()
			.query_filtered_once::<&CodegenFileSendit, With<FileGroupSendit>>()[0]
			.build_output()
			.unwrap()
			.to_token_stream()
			.to_string()
			.xpect()
			.to_be(quote::quote! {
				#![doc = r" ðŸŒ±ðŸŒ±ðŸŒ± This file has been auto generated by Beet."]
				#![doc = r" ðŸŒ±ðŸŒ±ðŸŒ± Any changes will be overridden if the file is regenerated."]
				#[allow(unused_imports)]
				use beet::prelude::*;
				#[allow(unused_imports)]
				use crate as test_site;
				#[path = "hello.rs"]
				mod route0;
				#[derive(Debug, Default, Clone)]
				pub struct TestDocsPlugin;
				impl TestDocsPlugin {}
				impl RouterPlugin for TestDocsPlugin {
					type State = ();
					type Meta = ();
					fn routes(&self) -> Vec<RouteInfo> {
						vec![RouteInfo {
							path: RoutePath(std::path::PathBuf::from("/hello")),
							method: HttpMethod::Get
						}]
					}
					fn meta(&self) -> Vec<Self::Meta> {
						vec![route0::meta()]
					}
					fn build(
						self,
						mut router: beet::exports::axum::Router<()>
					) -> beet::exports::axum::Router<()> {
						router = self.add_route(
							router,
							(RouteInfo {
								path: RoutePath(std::path::PathBuf::from("/hello")),
								method: HttpMethod::Get
							}, route0::get)
						);
						router
					}
				}

			}.to_string());
	}
}
