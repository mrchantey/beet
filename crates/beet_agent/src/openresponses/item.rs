//! Output item types for the OpenResponses API.
//!
//! This module contains types representing items that can appear in
//! a response's output array.
//!
//! # Items
//!
//! Items are the core unit of context in OpenResponses. They represent atomic
//! units of model output and follow a state machine lifecycle:
//!
//! - `in_progress`: Model is currently generating this item
//! - `completed`: Item is finalized
//! - `incomplete`: Item was interrupted (e.g., token limit reached)
//!
//! # Item Types
//!
//! The [`OutputItem`] enum represents all possible output item types:
//!
//! - **Message**: Text content from the model, with optional annotations
//! - **FunctionCall**: Tool invocation with function name and JSON arguments
//! - **FunctionCallOutput**: Result returned after executing a function
//! - **Reasoning**: Model's reasoning trace (for reasoning models like o1)
//!
//! # Extracting Content
//!
//! ```no_run
//! # use beet_agent::prelude::openresponses;
//! # fn example(output: &[openresponses::OutputItem]) {
//! for item in output {
//!     match item {
//!         openresponses::OutputItem::Message(msg) => {
//!             if let Some(text) = msg.first_text() {
//!                 println!("Assistant: {}", text);
//!             }
//!         }
//!         openresponses::OutputItem::FunctionCall(fc) => {
//!             println!("Call {}: {}", fc.name, fc.arguments);
//!         }
//!         _ => {}
//!     }
//! }
//! # }
//! ```

use super::content::*;
use super::enums::*;
use serde::Deserialize;
use serde::Serialize;

/// An output item from the model.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum OutputItem {
	/// A message output.
	Message(Message),
	/// A function call output.
	#[serde(rename = "function_call")]
	FunctionCall(FunctionCall),
	/// A function call result.
	#[serde(rename = "function_call_output")]
	FunctionCallOutput(FunctionCallOutputItem),
	/// A reasoning output.
	Reasoning(ReasoningItem),
}

impl OutputItem {
	/// Returns the item ID, if available.
	pub fn id(&self) -> Option<&str> {
		match self {
			Self::Message(msg) => Some(&msg.id),
			Self::FunctionCall(fc) => Some(&fc.id),
			Self::FunctionCallOutput(fco) => Some(&fco.id),
			Self::Reasoning(reasoning) => Some(&reasoning.id),
		}
	}

	/// Returns this item as a message, if it is one.
	pub fn as_message(&self) -> Option<&Message> {
		match self {
			Self::Message(msg) => Some(msg),
			_ => None,
		}
	}

	/// Returns this item as a function call, if it is one.
	pub fn as_function_call(&self) -> Option<&FunctionCall> {
		match self {
			Self::FunctionCall(fc) => Some(fc),
			_ => None,
		}
	}
}

/// A message output from the model.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Message {
	/// The unique ID of the message.
	pub id: String,
	/// The status of the message.
	pub status: MessageStatus,
	/// The role of the message. Always `"assistant"` for outputs.
	pub role: MessageRole,
	/// The content of the message.
	pub content: Vec<OutputContent>,
}

impl Message {
	/// Returns the first text content, if any.
	pub fn first_text(&self) -> Option<&str> {
		for content in &self.content {
			if let OutputContent::OutputText(text) = content {
				return Some(&text.text);
			}
		}
		None
	}

	/// Returns all text content concatenated.
	pub fn all_text(&self) -> String {
		self.content
			.iter()
			.filter_map(|content| {
				if let OutputContent::OutputText(text) = content {
					Some(text.text.as_str())
				} else {
					None
				}
			})
			.collect::<Vec<_>>()
			.join("")
	}
}

/// Content within an output message.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum OutputContent {
	/// A text output.
	#[serde(rename = "output_text")]
	OutputText(OutputText),
	/// A refusal.
	Refusal(Refusal),
}

/// A function call generated by the model.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct FunctionCall {
	/// The unique ID of the function call item.
	pub id: String,
	/// The unique ID of the function tool call.
	pub call_id: String,
	/// The name of the function that was called.
	pub name: String,
	/// The arguments JSON string that was generated.
	pub arguments: String,
	/// The status of the function call.
	/// Optional for provider compatibility (some providers omit this).
	#[serde(default)]
	pub status: Option<FunctionCallStatus>,
}

impl FunctionCall {
	/// Parses the arguments JSON string into a value.
	pub fn parse_arguments<T: serde::de::DeserializeOwned>(
		&self,
	) -> Result<T, serde_json::Error> {
		serde_json::from_str(&self.arguments)
	}

	/// Parses the arguments as a generic JSON value.
	pub fn arguments_value(
		&self,
	) -> Result<serde_json::Value, serde_json::Error> {
		serde_json::from_str(&self.arguments)
	}
}

/// A function call output item in the response.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct FunctionCallOutputItem {
	/// The unique ID of the function call output.
	pub id: String,
	/// The unique ID of the function tool call generated by the model.
	pub call_id: String,
	/// The output of the function call.
	pub output: String,
	/// The status of the item.
	pub status: FunctionCallStatus,
}

/// A reasoning item generated by the model.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReasoningItem {
	/// The unique ID of the reasoning item.
	pub id: String,
	/// The reasoning content.
	#[serde(default)]
	pub content: Vec<InputText>,
	/// The reasoning summary content.
	#[serde(default)]
	pub summary: Vec<SummaryText>,
	/// The encrypted reasoning content for rehydration.
	#[serde(default)]
	pub encrypted_content: Option<String>,
}

impl ReasoningItem {
	/// Returns the summary if available, otherwise the full text.
	pub fn summary_or_text(&self) -> String {
		if !self.summary.is_empty() {
			self.all_summary()
		} else {
			self.all_text()
		}
	}


	pub fn all_text(&self) -> String {
		self.content
			.iter()
			.map(|text| text.text.as_str())
			.collect::<Vec<_>>()
			.join("")
	}
	pub fn all_summary(&self) -> String {
		self.summary
			.iter()
			.map(|text| text.text.as_str())
			.collect::<Vec<_>>()
			.join("")
	}
}

#[cfg(test)]
mod test {
	use super::*;

	#[test]
	fn deserializes_message_item() {
		let json = r#"{
			"type": "message",
			"id": "msg_123",
			"status": "completed",
			"role": "assistant",
			"content": [
				{
					"type": "output_text",
					"text": "Hello, world!",
					"annotations": [],
					"logprobs": []
				}
			]
		}"#;

		let item: OutputItem = serde_json::from_str(json).unwrap();
		assert!(matches!(item, OutputItem::Message(_)));
		if let OutputItem::Message(msg) = item {
			assert_eq!(msg.id, "msg_123");
			assert_eq!(msg.first_text(), Some("Hello, world!"));
		}
	}

	#[test]
	fn deserializes_function_call_item() {
		let json = r#"{
			"type": "function_call",
			"id": "fc_123",
			"call_id": "call_abc",
			"name": "get_weather",
			"arguments": "{\"location\":\"NYC\"}",
			"status": "completed"
		}"#;

		let item: OutputItem = serde_json::from_str(json).unwrap();
		assert!(matches!(item, OutputItem::FunctionCall(_)));
		if let OutputItem::FunctionCall(fc) = item {
			assert_eq!(fc.name, "get_weather");
			let args: serde_json::Value = fc.parse_arguments().unwrap();
			assert_eq!(args["location"], "NYC");
		}
	}

	#[test]
	fn message_all_text() {
		let msg = Message {
			id: "msg_1".to_string(),
			status: MessageStatus::Completed,
			role: MessageRole::Assistant,
			content: vec![
				OutputContent::OutputText(OutputText::new("Hello, ")),
				OutputContent::OutputText(OutputText::new("world!")),
			],
		};
		assert_eq!(msg.all_text(), "Hello, world!");
	}
}
