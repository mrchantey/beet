use crate::prelude::syn_item_vec_serde;
use anyhow::Result;
use serde::Deserialize;
use serde::Serialize;
use std::path::Path;
use sweet::prelude::*;
use syn::Expr;
use syn::Item;



/// Every codegen file is created via this struct. It contains
/// several utilities and standards that make the whole thing nicer.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct CodegenFile {
	/// The output codegen file location.
	pub output: AbsPathBuf,
	/// All of the imports that must be included both globally and inside each
	/// inline module.
	#[serde(default, rename = "import_tokens", with = "syn_item_vec_serde")]
	pub imports: Vec<Item>,
	/// As `std::any::typename` resolves to a named crate, we need to alias the current
	/// crate to match any internal types, setting this option will add `use crate as pkg_name`
	/// to the top of the file.
	#[serde(rename = "package_name")]
	pub pkg_name: Option<String>,
	// List of all root level items to be included in the file.
	// These are usually appended to as this struct is passed around.
	#[serde(default, with = "syn_item_vec_serde")]
	pub items: Vec<Item>,
}


impl Default for CodegenFile {
	fn default() -> Self {
		Self {
			imports: vec![syn::parse_quote!(
				#[allow(unused_imports)]
				use beet::prelude::*;
			)],
			output: WorkspacePathBuf::new("src/codegen/mod.rs")
				.into_abs_unchecked(),
			pkg_name: None,
			items: Default::default(),
		}
	}
}

impl CodegenFile {
	/// Create a new [`CodegenFile`] with the most common options.
	pub fn new(output: AbsPathBuf) -> Self {
		Self {
			output,
			..Default::default()
		}
	}

	pub fn with_pkg_name(mut self, pkg_name: impl Into<String>) -> Self {
		self.pkg_name = Some(pkg_name.into());
		self
	}

	pub fn with_import(mut self, item: Item) -> Self {
		self.imports.push(item);
		self
	}


	pub fn output_dir(&self) -> Result<&Path> {
		self.output.parent().ok_or_else(|| {
			anyhow::anyhow!("Output path must have a parent directory")
		})
	}

	pub fn add_item<T: Into<syn::Item>>(&mut self, item: T) {
		self.items.push(item.into());
	}

	pub fn build_output(&self) -> Result<syn::File> {
		let imports = &self.imports;
		let crate_alias = self.crate_alias()?;

		let items = &self.items;

		Ok(syn::parse_quote! {
			//! ðŸŒ±ðŸŒ±ðŸŒ± This file has been auto generated by Beet.
			//! ðŸŒ±ðŸŒ±ðŸŒ± Any changes will be overridden if the file is regenerated.
			#(#imports)*
			#crate_alias
			#(#items)*
		})
	}

	pub fn build_and_write(&self) -> Result<()> {
		let output_tokens = self.build_output()?;
		let output_str = prettyplease::unparse(&output_tokens);

		FsExt::write(&self.output, &output_str)?;
		Ok(())
	}
	fn crate_alias(&self) -> Result<Option<syn::Item>> {
		if let Some(pkg_name) = &self.pkg_name {
			let pkg_name: Expr = syn::parse_str(pkg_name)?;
			Ok(Some(syn::parse_quote! {
				#[allow(unused_imports)]
				use crate as #pkg_name;
			}))
		} else {
			Ok(None)
		}
	}
}



#[cfg(test)]
mod test {
	use crate::prelude::*;
	use quote::ToTokens;
	use sweet::prelude::*;
	use syn::ItemFn;

	#[test]
	fn works() {
		let mut file = CodegenFile::default();
		file.add_item::<ItemFn>(syn::parse_quote! {
			fn test() {}
		});
		expect(&file.build_output().unwrap().to_token_stream().to_string())
			.to_contain("fn test () { }");
	}
}
