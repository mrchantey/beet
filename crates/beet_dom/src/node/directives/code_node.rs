//! Code node directive for syntax highlighting.
//!
//! This module provides the [`CodeNode`] component for marking elements
//! that should have syntax highlighting applied.

use crate::prelude::*;
use beet_core::prelude::*;





/// An element containing code, this element will be replaced by the `<pre>`
/// generated by syntect.
#[derive(Debug, Default, Clone, PartialEq, Hash, Component, Reflect)]
#[reflect(Component)]
#[component(immutable)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "tokens", derive(ToTokens))]
pub struct CodeNode {
	/// Override the [`SyntectConfig::theme`] lang for this code node.
	pub lang: Option<String>,
	/// Override the [`SyntectConfig::theme`] theme for this code node.
	pub theme: Option<String>,
}
impl CodeNode {
	/// Create a new [`CodeNode`] with the given language.
	pub fn new(lang: impl Into<String>) -> Self {
		Self {
			lang: Some(lang.into()),
			theme: None,
		}
	}
}



/// Extracts code node directives from element attributes.
///
/// This system finds elements with `node:code` attributes and replaces
/// them with [`CodeNode`] components.
pub fn extract_code_nodes(
	mut commands: Commands,
	query: Populated<Entity, Added<ElementNode>>,
	attributes: FindAttribute,
) {
	for node_ent in query.iter() {
		if let Some((attr_entity, _)) = attributes.find(node_ent, "node:code") {
			commands.entity(attr_entity).despawn();

			let lang =
				attributes.find_value(node_ent, "lang").map(|(entity, v)| {
					commands.entity(entity).despawn();
					v.0.clone()
				});
			let theme =
				attributes.find_value(node_ent, "theme").map(|(entity, v)| {
					commands.entity(entity).despawn();
					v.0.clone()
				});
			commands.entity(node_ent).insert(CodeNode { lang, theme });
		}
	}
}
