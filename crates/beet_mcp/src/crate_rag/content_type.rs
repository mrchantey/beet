use rmcp::schemars;
use rmcp::schemars::JsonSchema;
use serde::Deserialize;
use serde::Serialize;



#[derive(
	Debug, Clone, Hash, PartialEq, Eq, Serialize, Deserialize, JsonSchema,
)]
/// this absolutely sucks but schemars/rcmp so broken
pub struct ContentTypeStr {
	#[schemars(description = "\
The type of content to query for. this can **only** be one of
['docs', 'guides', 'examples', 'internals']. 
## Examples
The reccommended type depends on the query, for example:

### 'docs'

These are the api docs, generated by rustdoc. Useful for information
on specific types, functions, or traits. Use this for queries like:

- 'how to use App.add_systems()?'

### 'guides'

Published notes by a crates website, including release notes, migration guides and 
community news.

Some new features are not yet in docs and examples, so guides can sometimes be used
for information on new features. However be careful because this also includes release
notes for older versions with deprecated apis.

- 'how does the new related! macro work?'

### 'examples'

Files in the `examples/` of a crate, containing many examples of how to use the crate.
This is great for high level queries:

- 'lets create a simple 3d scene'

### 'internals'

The source code of the crate itself, useful for understanding how the crate internals work,
or when making changes to the crate itself.

- 'help me add the NonSend attribute to the Component trait'


When in doubt, go with 'examples' as that provides the most holistic usage patterns.
If the first query does not return relevant results, try another type.
")]
	pub content_type: String,
}

impl Default for ContentTypeStr {
	fn default() -> Self { ContentType::default().into() }
}


impl Into<ContentType> for ContentTypeStr {
	fn into(self) -> ContentType {
		ContentType::try_from(self.content_type.as_str()).unwrap_or_default()
	}
}


#[derive(
	Debug,
	Default,
	Copy,
	Clone,
	Hash,
	PartialEq,
	Eq,
	Serialize,
	Deserialize,
	JsonSchema,
)]
pub enum ContentType {
	#[default]
	Docs,
	Guides,
	Examples,
	Internals,
}


impl std::fmt::Display for ContentType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			ContentType::Docs => write!(f, "docs"),
			ContentType::Guides => write!(f, "guides"),
			ContentType::Examples => write!(f, "examples"),
			ContentType::Internals => write!(f, "internals"),
		}
	}
}


impl TryFrom<&str> for ContentType {
	type Error = anyhow::Error;

	fn try_from(value: &str) -> Result<Self, Self::Error> {
		match value {
			"docs" => Ok(ContentType::Docs),
			"guides" => Ok(ContentType::Guides),
			"examples" => Ok(ContentType::Examples),
			"internals" => Ok(ContentType::Internals),
			_ => anyhow::bail!("Invalid Content Type: {}", value),
		}
	}
}

impl Into<ContentTypeStr> for ContentType {
	fn into(self) -> ContentTypeStr {
		ContentTypeStr {
			content_type: self.to_string(),
		}
	}
}
