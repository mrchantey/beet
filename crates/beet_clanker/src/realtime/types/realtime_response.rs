use crate::realtime::types as models;
use serde::Deserialize;
use serde::Serialize;

/// RealtimeResponse : The response resource.
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct RealtimeResponse {
	/// The unique ID of the response.
	#[serde(rename = "id", skip_serializing_if = "Option::is_none")]
	pub id: Option<String>,
	/// The object type, must be `realtime.response`.
	#[serde(rename = "object", skip_serializing_if = "Option::is_none")]
	pub object: Option<Object>,
	/// The final status of the response (`completed`, `cancelled`, `failed`, or  `incomplete`).
	#[serde(rename = "status", skip_serializing_if = "Option::is_none")]
	pub status: Option<Status>,
	#[serde(
		rename = "status_details",
		skip_serializing_if = "Option::is_none"
	)]
	pub status_details: Option<Box<models::RealtimeResponseStatusDetails>>,
	/// The list of output items generated by the response.
	#[serde(rename = "output", skip_serializing_if = "Option::is_none")]
	pub output: Option<Vec<models::RealtimeConversationItem>>,
	/// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format, and querying for objects via API or the dashboard.   Keys are strings with a maximum length of 64 characters. Values are strings with a maximum length of 512 characters.
	#[serde(
		rename = "metadata",
		default,
		with = "::serde_with::rust::double_option",
		skip_serializing_if = "Option::is_none"
	)]
	pub metadata: Option<Option<std::collections::HashMap<String, String>>>,
	#[serde(rename = "usage", skip_serializing_if = "Option::is_none")]
	pub usage: Option<Box<models::RealtimeResponseUsage>>,
	/// Which conversation the response is added to, determined by the `conversation` field in the `response.create` event. If `auto`, the response will be added to the default conversation and the value of `conversation_id` will be an id like `conv_1234`. If `none`, the response will not be added to any conversation and the value of `conversation_id` will be `null`. If responses are being triggered by server VAD, the response will be added to the default conversation, thus the `conversation_id` will be an id like `conv_1234`.
	#[serde(
		rename = "conversation_id",
		skip_serializing_if = "Option::is_none"
	)]
	pub conversation_id: Option<String>,
	#[serde(rename = "voice", skip_serializing_if = "Option::is_none")]
	pub voice: Option<Box<models::VoiceIdsShared>>,
	/// The set of modalities the model used to respond. If there are multiple modalities, the model will pick one, for example if `modalities` is `[\"text\", \"audio\"]`, the model could be responding in either text or audio.
	#[serde(rename = "modalities", skip_serializing_if = "Option::is_none")]
	pub modalities: Option<Vec<Modalities>>,
	/// The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.
	#[serde(
		rename = "output_audio_format",
		skip_serializing_if = "Option::is_none"
	)]
	pub output_audio_format: Option<OutputAudioFormat>,
	/// Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.
	#[serde(rename = "temperature", skip_serializing_if = "Option::is_none")]
	pub temperature: Option<f64>,
	#[serde(
		rename = "max_output_tokens",
		skip_serializing_if = "Option::is_none"
	)]
	pub max_output_tokens: Option<Box<models::RealtimeResponseMaxOutputTokens>>,
}

impl RealtimeResponse {
	/// The response resource.
	pub fn new() -> RealtimeResponse {
		RealtimeResponse {
			id: None,
			object: None,
			status: None,
			status_details: None,
			output: None,
			metadata: None,
			usage: None,
			conversation_id: None,
			voice: None,
			modalities: None,
			output_audio_format: None,
			temperature: None,
			max_output_tokens: None,
		}
	}
}
/// The object type, must be `realtime.response`.
#[derive(
	Clone,
	Copy,
	Debug,
	Eq,
	PartialEq,
	Ord,
	PartialOrd,
	Hash,
	Serialize,
	Deserialize,
)]
pub enum Object {
	#[serde(rename = "realtime.response")]
	RealtimePeriodResponse,
}

impl Default for Object {
	fn default() -> Object { Self::RealtimePeriodResponse }
}
/// The final status of the response (`completed`, `cancelled`, `failed`, or  `incomplete`).
#[derive(
	Clone,
	Copy,
	Debug,
	Eq,
	PartialEq,
	Ord,
	PartialOrd,
	Hash,
	Serialize,
	Deserialize,
)]
pub enum Status {
	#[serde(rename = "completed")]
	Completed,
	#[serde(rename = "cancelled")]
	Cancelled,
	#[serde(rename = "failed")]
	Failed,
	#[serde(rename = "incomplete")]
	Incomplete,
}

impl Default for Status {
	fn default() -> Status { Self::Completed }
}
/// The set of modalities the model used to respond. If there are multiple modalities, the model will pick one, for example if `modalities` is `[\"text\", \"audio\"]`, the model could be responding in either text or audio.
#[derive(
	Clone,
	Copy,
	Debug,
	Eq,
	PartialEq,
	Ord,
	PartialOrd,
	Hash,
	Serialize,
	Deserialize,
)]
pub enum Modalities {
	#[serde(rename = "text")]
	Text,
	#[serde(rename = "audio")]
	Audio,
}

impl Default for Modalities {
	fn default() -> Modalities { Self::Text }
}
/// The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.
#[derive(
	Clone,
	Copy,
	Debug,
	Eq,
	PartialEq,
	Ord,
	PartialOrd,
	Hash,
	Serialize,
	Deserialize,
)]
pub enum OutputAudioFormat {
	#[serde(rename = "pcm16")]
	Pcm16,
	#[serde(rename = "g711_ulaw")]
	G711Ulaw,
	#[serde(rename = "g711_alaw")]
	G711Alaw,
}

impl Default for OutputAudioFormat {
	fn default() -> OutputAudioFormat { Self::Pcm16 }
}
