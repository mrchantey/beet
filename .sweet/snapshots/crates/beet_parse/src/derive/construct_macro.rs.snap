[
  "use beet_core::prelude::*;\n/// probably the best templating layout ever\n#[derive(Component, Clone)]\n#[component(on_add = on_add_my_node)]\npub(crate) struct MyNode {\n    /// some comment\n    pub foo: u32,\n    pub bar: u32,\n}\nfn on_add_my_node(mut world: DeferredWorld, cx: HookContext) {\n    let entity = cx.entity;\n    world\n        .commands()\n        .queue(move |world: &mut World| {\n            let mut entity_world_mut = world.entity_mut(entity);\n            let id = entity_world_mut.id();\n            let this = entity_world_mut.get::<MyNode>().unwrap().clone();\n            let bundle: _ = {\n                #[allow(unused_variables, unused_assignments)]\n                let entity = id;\n                #[allow(unused_variables, unused_assignments)]\n                let MyNode { foo, mut bar } = this;\n                ()\n            };\n            entity_world_mut.insert(bundle);\n        });\n}\n",
  "use beet_core::prelude::*;\n#[derive(Component)]\n#[component(on_add = on_add_my_node)]\npub(crate) struct MyNode {\n    pub foo: u32,\n}\nfn on_add_my_node(mut world: DeferredWorld, cx: HookContext) {\n    let entity = cx.entity;\n    world\n        .commands()\n        .queue(move |world: &mut World| {\n            let mut entity_world_mut = world.entity_mut(entity);\n            let id = entity_world_mut.id();\n            let this = entity_world_mut.take::<MyNode>().unwrap();\n            let bundle: _ = {\n                #[allow(unused_variables, unused_assignments)]\n                let entity = id;\n                #[allow(unused_variables, unused_assignments)]\n                let MyNode { foo } = this;\n                ()\n            };\n            entity_world_mut.insert(bundle);\n        });\n}\n",
  "use beet_core::prelude::*;\n#[derive(Component, Clone)]\n#[component(on_add = on_add_my_node)]\npub(crate) struct MyNode {\n    pub foo: u32,\n}\nfn on_add_my_node(mut world: DeferredWorld, cx: HookContext) {\n    let entity = cx.entity;\n    world\n        .commands()\n        .queue(move |world: &mut World| {\n            let mut entity_world_mut = world.entity_mut(entity);\n            let id = entity_world_mut.id();\n            let this = entity_world_mut.get::<MyNode>().unwrap().clone();\n            let bundle: _ = {\n                fn system(\n                    #[allow(unused_variables, unused_assignments)]\n                    In((entity, this)): In<(Entity, MyNode)>,\n                    mut my_res: Res<Time>,\n                ) -> impl Bundle + use<> {\n                    #[allow(unused_variables, unused_assignments)]\n                    let MyNode { foo } = this;\n                    ()\n                }\n                entity_world_mut\n                    .world_scope(|world| {\n                        world\n                            .run_system_cached_with(system, (id, this))\n                            .map_err(|err| {\n                                bevyhow!(\n                                    \"Error running template system for `MyNode`: {}\", err\n                                )\n                            })\n                            .unwrap_or_exit()\n                    })\n            };\n            entity_world_mut.insert(bundle);\n        });\n}\n",
  "use beet_core::prelude::*;\n#[derive(Component, Clone)]\n#[component(on_add = on_add_my_node)]\npub(crate) struct MyNode {\n    pub boo: u32,\n}\nfn on_add_my_node(mut world: DeferredWorld, cx: HookContext) {\n    let entity = cx.entity;\n    world\n        .commands()\n        .queue(move |world: &mut World| {\n            let mut entity_world_mut = world.entity_mut(entity);\n            let id = entity_world_mut.id();\n            let this = entity_world_mut.get::<MyNode>().unwrap().clone();\n            world\n                .run_async_local(async move |world| {\n                    let bar = world.entity(id);\n                    let bundle: _ = {\n                        #[allow(unused_variables, unused_assignments)]\n                        let MyNode { boo } = this;\n                        ()\n                    };\n                    bar.insert(bundle).await;\n                });\n        });\n}\n",
  "use beet_core::prelude::*;\n#[derive(Component, Clone)]\n#[component(on_add = on_add_my_node)]\npub(crate) struct MyNode {\n    pub foo: u32,\n}\nfn on_add_my_node(mut world: DeferredWorld, cx: HookContext) {\n    let entity = cx.entity;\n    world\n        .commands()\n        .queue(move |world: &mut World| {\n            let mut entity_world_mut = world.entity_mut(entity);\n            let id = entity_world_mut.id();\n            let this = entity_world_mut.get::<MyNode>().unwrap().clone();\n            let mut bar = entity_world_mut;\n            let bundle: _ = {\n                #[allow(unused_variables, unused_assignments)]\n                #[allow(unused_variables, unused_assignments)]\n                let MyNode { foo } = this;\n                ()\n            };\n            bar.insert(bundle);\n        });\n}\n",
  "use beet_core::prelude::*;\n/// probably the best templating layout ever\n#[derive(Component, Clone)]\n#[component(on_add = on_add_my_node)]\npub(crate) struct MyNode {\n    /// some comment\n    pub foo: u32,\n    pub bar: u32,\n}\nfn on_add_my_node(mut world: DeferredWorld, cx: HookContext) {\n    let entity = cx.entity;\n    world\n        .commands()\n        .queue(move |world: &mut World| {\n            let mut entity_world_mut = world.entity_mut(entity);\n            let id = entity_world_mut.id();\n            let this = entity_world_mut.get::<MyNode>().unwrap().clone();\n            let bundle: _ = {\n                fn system(\n                    #[allow(unused_variables, unused_assignments)]\n                    In((my_entity, this)): In<(Entity, MyNode)>,\n                    world: &mut World,\n                    res: Res<Time>,\n                    mut query: Query<&mut Transform>,\n                ) -> impl Bundle + use<> {\n                    #[allow(unused_variables, unused_assignments)]\n                    let MyNode { foo, mut bar } = this;\n                    ()\n                }\n                entity_world_mut\n                    .world_scope(|world| {\n                        world\n                            .run_system_cached_with(system, (id, this))\n                            .map_err(|err| {\n                                bevyhow!(\n                                    \"Error running template system for `MyNode`: {}\", err\n                                )\n                            })\n                            .unwrap_or_exit()\n                    })\n            };\n            entity_world_mut.insert(bundle);\n        });\n}\n",
]